# RFC 00001: High-Performance Rust + napi-rs + Node.js Web Server

- **Status**: Draft
- **Created**: 2026-01-18
- **Authors**: fetch-rs team

## 1. Executive Summary

### Problem Statement

Node.js web servers face inherent performance limitations due to:

- Single-threaded JavaScript execution for request handling
- V8's memory management overhead for buffer operations
- HTTP parsing overhead in JavaScript userland

While Node.js excels at I/O-bound async operations, CPU-intensive tasks like HTTP parsing and TLS handling can become bottlenecks at scale.

### Goals

1. **Performance**: Achieve 80-150K RPS for simple JSON responses (2-3x native Node.js HTTP)
2. **Zero-Copy**: Minimize memory allocations and copies between Rust and Node.js
3. **Developer Experience**: Familiar Fetch Event API pattern from Service Workers/Cloudflare Workers
4. **Compatibility**: Support standard Request/Response interfaces

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Node.js Process                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    JavaScript Layer                           │   │
│  │  ┌─────────────────┐    ┌─────────────────────────────────┐  │   │
│  │  │   User Handler   │    │     FetchEvent API (TypeScript) │  │   │
│  │  │                  │    │  - Request                      │  │   │
│  │  │  addEventListener│    │  - Response                     │  │   │
│  │  │  ('fetch', ...)  │    │  - Headers                      │  │   │
│  │  └────────┬─────────┘    └───────────────┬─────────────────┘  │   │
│  │           │                              │                     │   │
│  └───────────┼──────────────────────────────┼─────────────────────┘   │
│              │                              │                         │
│              │        napi-rs FFI           │                         │
│              ▼                              ▼                         │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                      Rust Layer                               │   │
│  │  ┌─────────────────────────────────────────────────────────┐ │   │
│  │  │                   napi-rs Bindings                       │ │   │
│  │  │  - ThreadsafeFunction (JS callback invocation)          │ │   │
│  │  │  - Buffer/BufferSlice (zero-copy data transfer)         │ │   │
│  │  │  - JsResponse (response handling)                       │ │   │
│  │  └────────────────────────┬────────────────────────────────┘ │   │
│  │                           │                                   │   │
│  │  ┌────────────────────────▼────────────────────────────────┐ │   │
│  │  │                    Axum HTTP Server                      │ │   │
│  │  │  - hyper (HTTP/1.1, HTTP/2)                             │ │   │
│  │  │  - tower (middleware)                                    │ │   │
│  │  │  - tokio (async runtime)                                 │ │   │
│  │  └─────────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ TCP/TLS
                                    ▼
                              ┌──────────┐
                              │  Client  │
                              └──────────┘
```

## 2. Architecture Design

### System Components

| Component           | Responsibility                                         |
| ------------------- | ------------------------------------------------------ |
| **Axum Server**     | HTTP protocol handling, routing, connection management |
| **napi-rs Bridge**  | Zero-copy data transfer, ThreadsafeFunction callbacks  |
| **FetchEvent API**  | JavaScript interface for request/response handling     |
| **Request Context** | Holds request data and response channel                |
| **Body Handle**     | Streaming body read/write interface                    |

### Threading Model

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Tokio Runtime                              │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │  Worker Thread Pool (N threads, default: CPU cores)              ││
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐            ││
│  │  │ Worker 1 │ │ Worker 2 │ │ Worker 3 │ │ Worker N │            ││
│  │  │  Tasks   │ │  Tasks   │ │  Tasks   │ │  Tasks   │            ││
│  │  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘            ││
│  │       │            │            │            │                   ││
│  │       └────────────┴─────┬──────┴────────────┘                   ││
│  │                          │                                       ││
│  │                          ▼                                       ││
│  │            ┌─────────────────────────────┐                       ││
│  │            │    ThreadsafeFunction       │                       ││
│  │            │    (Single Shared Instance) │                       ││
│  │            └──────────────┬──────────────┘                       ││
│  └───────────────────────────┼──────────────────────────────────────┘│
└──────────────────────────────┼───────────────────────────────────────┘
                               │
                               ▼
              ┌────────────────────────────────────────┐
              │          Node.js Event Loop            │
              │  ┌──────────────────────────────────┐  │
              │  │     JavaScript Handler Execution │  │
              │  │     (Single-threaded)            │  │
              │  └──────────────────────────────────┘  │
              └────────────────────────────────────────┘
```

**Key Points**:

- Tokio runtime uses multi-threaded scheduler (N worker threads)
- Single `ThreadsafeFunction` shared across all workers
- Node.js event loop handles JavaScript execution single-threaded
- Async responses via `oneshot` channels back to Tokio tasks

### Data Flow: Request → Handler → Response

```
┌─────────┐      ┌──────────────┐      ┌─────────────────┐
│ Client  │─────▶│  Axum/hyper  │─────▶│  RequestContext │
└─────────┘      └──────────────┘      └────────┬────────┘
   HTTP                                         │
                                               │ ThreadsafeFunction.call_async()
                                               ▼
                              ┌─────────────────────────────────┐
                              │      JavaScript Handler         │
                              │  ┌───────────────────────────┐  │
                              │  │  const event = new        │  │
                              │  │    FetchEvent(request);   │  │
                              │  │  event.respondWith(       │  │
                              │  │    handler(request));     │  │
                              │  └───────────────────────────┘  │
                              └──────────────┬──────────────────┘
                                             │
                                             │ Promise<JsResponse>
                                             ▼
┌─────────┐      ┌──────────────┐      ┌─────────────────┐
│ Client  │◀─────│  Axum/hyper  │◀─────│  Response Body  │
└─────────┘      └──────────────┘      └─────────────────┘
   HTTP                                 (zero-copy Buffer)
```

## 3. API Design

### 3.1 JavaScript API - Fetch Event Pattern

```typescript
// Handler registration
server.addEventListener("fetch", (event: FetchEvent) => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request: Request): Promise<Response> {
  const url = new URL(request.url);

  if (url.pathname === "/api/data") {
    return Response.json({ message: "Hello, World!" });
  }

  if (url.pathname === "/api/echo") {
    const body = await request.text();
    return new Response(body, {
      headers: { "Content-Type": "text/plain" },
    });
  }

  return new Response("Not Found", { status: 404 });
}
```

### 3.2 Server Class API

```typescript
interface ServerOptions {
  /** Port to listen on */
  port: number;
  /** Host to bind to (default: '0.0.0.0') */
  host?: string;
  /** Enable SO_REUSEPORT for multi-core scaling */
  reusePort?: boolean;
  /** Maximum concurrent connections (default: 65536) */
  maxConnections?: number;
  /** Request body size limit in bytes (default: 10MB) */
  maxBodySize?: number;
  /** Request timeout in milliseconds (default: 30000) */
  timeout?: number;
}

class Server {
  constructor(options: ServerOptions);

  /** Register a fetch event handler */
  addEventListener(event: "fetch", handler: (event: FetchEvent) => void): void;

  /** Start the server */
  listen(): Promise<void>;

  /** Gracefully shutdown the server */
  close(): Promise<void>;

  /** Get server statistics */
  stats(): ServerStats;
}

interface ServerStats {
  activeConnections: number;
  totalRequests: number;
  requestsPerSecond: number;
  avgLatencyMs: number;
}
```

### 3.3 FetchEvent Class

```typescript
class FetchEvent {
  /** The incoming request */
  readonly request: Request;

  /** Client IP address */
  readonly clientAddress: string;

  /**
   * Provide a Response to the request.
   * Must be called exactly once.
   */
  respondWith(response: Response | Promise<Response>): void;

  /**
   * Extend the event lifetime for background tasks.
   * The response is still sent immediately.
   */
  waitUntil(promise: Promise<unknown>): void;
}
```

### 3.4 Request Class (WinterCG Compatible)

```typescript
class Request {
  constructor(input: string | URL | Request, init?: RequestInit);

  readonly method: string;
  readonly url: string;
  readonly headers: Headers;
  readonly body: ReadableStream<Uint8Array> | null;
  readonly bodyUsed: boolean;

  /** Parse body as ArrayBuffer */
  arrayBuffer(): Promise<ArrayBuffer>;

  /** Parse body as Blob */
  blob(): Promise<Blob>;

  /** Parse body as FormData */
  formData(): Promise<FormData>;

  /** Parse body as JSON */
  json<T = unknown>(): Promise<T>;

  /** Parse body as text */
  text(): Promise<string>;

  /** Clone the request */
  clone(): Request;
}
```

### 3.5 Response Class (WinterCG Compatible)

```typescript
class Response {
  constructor(body?: BodyInit | null, init?: ResponseInit);

  readonly status: number;
  readonly statusText: string;
  readonly ok: boolean;
  readonly headers: Headers;
  readonly body: ReadableStream<Uint8Array> | null;
  readonly bodyUsed: boolean;

  /** Create a JSON response */
  static json(data: unknown, init?: ResponseInit): Response;

  /** Create a redirect response */
  static redirect(url: string, status?: number): Response;

  /** Create an error response */
  static error(): Response;

  /** Parse body methods (same as Request) */
  arrayBuffer(): Promise<ArrayBuffer>;
  blob(): Promise<Blob>;
  formData(): Promise<FormData>;
  json<T = unknown>(): Promise<T>;
  text(): Promise<string>;

  clone(): Response;
}
```

### 3.6 Rust napi-rs Bindings

```rust
// src/lib.rs - Main exports
#[napi]
pub struct Server {
    inner: Arc<ServerInner>,
}

#[napi]
impl Server {
    #[napi(constructor)]
    pub fn new(options: ServerOptions) -> Result<Self>;

    #[napi]
    pub fn set_handler(&self, handler: ThreadsafeFunction<RequestContext>) -> Result<()>;

    #[napi]
    pub async fn listen(&self) -> Result<()>;

    #[napi]
    pub async fn close(&self) -> Result<()>;

    #[napi]
    pub fn stats(&self) -> ServerStats;
}

// Request context passed to JavaScript
#[napi(object)]
pub struct RequestContext {
    pub method: String,
    pub url: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<Buffer>,
    pub client_address: String,
    #[napi(ts_type = "(response: JsResponse) => void")]
    pub respond: JsFunction,
}

// Response from JavaScript
#[napi(object)]
pub struct JsResponse {
    pub status: u16,
    pub headers: Vec<(String, String)>,
    pub body: Option<Buffer>,
}
```

### 3.7 TypeScript Type Definitions

```typescript
// types/index.d.ts
export interface ServerOptions {
  port: number;
  host?: string;
  reusePort?: boolean;
  maxConnections?: number;
  maxBodySize?: number;
  timeout?: number;
}

export interface ServerStats {
  activeConnections: number;
  totalRequests: number;
  requestsPerSecond: number;
  avgLatencyMs: number;
}

export interface RequestContext {
  method: string;
  url: string;
  headers: Array<[string, string]>;
  body: Buffer | null;
  clientAddress: string;
  respond: (response: JsResponse) => void;
}

export interface JsResponse {
  status: number;
  headers: Array<[string, string]>;
  body: Buffer | null;
}

export class Server {
  constructor(options: ServerOptions);
  addEventListener(event: "fetch", handler: (event: FetchEvent) => void): void;
  listen(): Promise<void>;
  close(): Promise<void>;
  stats(): ServerStats;
}
```

## 4. Zero-Copy Data Transfer Strategy

### 4.1 Request Direction: Rust → Node.js

#### Small Bodies (< 1MB): Buffered Transfer

```rust
// Zero-copy buffer transfer using napi-rs
fn create_request_context(
    req: hyper::Request<hyper::Body>,
    respond_tx: oneshot::Sender<Response>,
) -> RequestContext {
    let (parts, body) = req.into_parts();

    // Collect body bytes (for small bodies)
    let body_bytes: Vec<u8> = body.collect().await?.to_bytes().to_vec();

    // Zero-copy: Buffer takes ownership of Vec<u8>
    let buffer = Buffer::from(body_bytes);

    RequestContext {
        method: parts.method.to_string(),
        url: parts.uri.to_string(),
        headers: extract_headers(&parts.headers),
        body: Some(buffer),  // Ownership transferred to JS
        client_address: client_addr.to_string(),
        respond: create_respond_fn(respond_tx),
    }
}
```

#### Large Bodies (>= 1MB): Streaming Transfer

```rust
// Streaming body handle for large payloads
#[napi]
pub struct BodyHandle {
    receiver: Option<mpsc::Receiver<Bytes>>,
}

#[napi]
impl BodyHandle {
    #[napi]
    pub async fn read(&mut self) -> Result<Option<Buffer>> {
        if let Some(ref mut rx) = self.receiver {
            match rx.recv().await {
                Some(chunk) => Ok(Some(Buffer::from(chunk.to_vec()))),
                None => Ok(None), // Stream ended
            }
        } else {
            Ok(None)
        }
    }
}
```

### 4.2 Response Direction: Node.js → Rust

```typescript
// JavaScript side - Response preparation
class FetchEvent {
  respondWith(responsePromise: Response | Promise<Response>): void {
    Promise.resolve(responsePromise).then((response) => {
      // Convert Response to JsResponse for Rust
      const jsResponse: JsResponse = {
        status: response.status,
        headers: Array.from(response.headers.entries()),
        body: response._bodyBuffer, // Pre-extracted Buffer
      };
      this._respond(jsResponse);
    });
  }
}
```

```rust
// Rust side - Response handling
async fn handle_js_response(
    js_response: JsResponse,
    respond_tx: oneshot::Sender<hyper::Response<Body>>,
) {
    let mut builder = hyper::Response::builder()
        .status(js_response.status);

    for (name, value) in js_response.headers {
        builder = builder.header(name, value);
    }

    let body = match js_response.body {
        Some(buffer) => {
            // Zero-copy: Buffer's underlying memory is used directly
            Body::from(buffer.to_vec())
        }
        None => Body::empty(),
    };

    let response = builder.body(body).unwrap();
    let _ = respond_tx.send(response);
}
```

### 4.3 Memory Lifecycle

```
Request Flow:
┌─────────────┐    ┌──────────────┐    ┌─────────────────┐
│  TCP Read   │───▶│  hyper Body  │───▶│  Vec<u8> alloc  │
│  (kernel)   │    │  (streaming) │    │  (Rust heap)    │
└─────────────┘    └──────────────┘    └────────┬────────┘
                                                │
                                                │ Buffer::from() - ownership transfer
                                                ▼
                                       ┌─────────────────┐
                                       │  napi Buffer    │
                                       │  (V8 external)  │
                                       └────────┬────────┘
                                                │
                                                │ Accessed in JS
                                                ▼
                                       ┌─────────────────┐
                                       │  JS ArrayBuffer │
                                       │  (V8 managed)   │
                                       └────────┬────────┘
                                                │
                                                │ GC when unreachable
                                                ▼
                                       ┌─────────────────┐
                                       │  Memory freed   │
                                       └─────────────────┘

Response Flow:
┌─────────────────┐    ┌──────────────┐    ┌─────────────────┐
│  JS Response    │───▶│  Buffer      │───▶│  Rust receives  │
│  (user creates) │    │  (JS heap)   │    │  (borrowed ref) │
└─────────────────┘    └──────────────┘    └────────┬────────┘
                                                    │
                                                    │ to_vec() - copy required
                                                    ▼
                                           ┌─────────────────┐
                                           │  hyper Body     │
                                           │  (Rust owned)   │
                                           └────────┬────────┘
                                                    │
                                                    │ TCP write
                                                    ▼
                                           ┌─────────────────┐
                                           │  Response sent  │
                                           └─────────────────┘
```

## 5. Performance Optimization

### 5.1 Connection Handling

#### SO_REUSEPORT for Multi-Core Scaling

```rust
use socket2::{Domain, Socket, Type};

fn create_listener(addr: SocketAddr, reuse_port: bool) -> std::io::Result<TcpListener> {
    let socket = Socket::new(Domain::IPV4, Type::STREAM, None)?;

    socket.set_reuse_address(true)?;

    #[cfg(unix)]
    if reuse_port {
        socket.set_reuse_port(true)?;
    }

    socket.set_nonblocking(true)?;
    socket.bind(&addr.into())?;
    socket.listen(8192)?;  // Large backlog

    TcpListener::from_std(socket.into())
}
```

#### Thread Pool Sizing

```rust
fn build_runtime(config: &ServerConfig) -> tokio::runtime::Runtime {
    tokio::runtime::Builder::new_multi_thread()
        .worker_threads(config.worker_threads.unwrap_or_else(num_cpus::get))
        .enable_all()
        .build()
        .expect("Failed to build Tokio runtime")
}
```

### 5.2 Request Queuing and Backpressure

```rust
pub struct RequestQueue {
    semaphore: Arc<Semaphore>,
    max_pending: usize,
}

impl RequestQueue {
    pub fn new(max_pending: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_pending)),
            max_pending,
        }
    }

    pub async fn acquire(&self) -> Result<SemaphorePermit<'_>, QueueFullError> {
        match self.semaphore.try_acquire() {
            Ok(permit) => Ok(permit),
            Err(_) => {
                // Queue full - apply backpressure
                Err(QueueFullError)
            }
        }
    }
}
```

### 5.3 Buffer Pooling

```rust
use bytes::BytesMut;
use std::sync::Mutex;

pub struct BufferPool {
    pool: Mutex<Vec<BytesMut>>,
    buffer_size: usize,
    max_buffers: usize,
}

impl BufferPool {
    pub fn new(buffer_size: usize, max_buffers: usize) -> Self {
        Self {
            pool: Mutex::new(Vec::with_capacity(max_buffers)),
            buffer_size,
            max_buffers,
        }
    }

    pub fn get(&self) -> BytesMut {
        let mut pool = self.pool.lock().unwrap();
        pool.pop().unwrap_or_else(|| BytesMut::with_capacity(self.buffer_size))
    }

    pub fn put(&self, mut buffer: BytesMut) {
        buffer.clear();
        let mut pool = self.pool.lock().unwrap();
        if pool.len() < self.max_buffers {
            pool.push(buffer);
        }
    }
}
```

### 5.4 Performance Targets

| Scenario                  | Target RPS | Latency p50 | Latency p99 | Notes                         |
| ------------------------- | ---------- | ----------- | ----------- | ----------------------------- |
| Simple JSON response      | 80-150K    | < 1ms       | < 5ms       | `Response.json({ ok: true })` |
| Echo request body (1KB)   | 50-100K    | < 2ms       | < 10ms      | Read body, return as-is       |
| Echo request body (100KB) | 20-50K     | < 5ms       | < 20ms      | Larger body handling          |
| Database query            | 20-50K     | < 10ms      | < 50ms      | External I/O bound            |
| File serving (static)     | 30-60K     | < 2ms       | < 10ms      | Cached file reads             |

### 5.5 Benchmarking Methodology

```bash
# Install benchmarking tools
cargo install oha  # HTTP load generator written in Rust

# Simple JSON benchmark
oha -c 100 -z 30s http://localhost:3000/api/health

# Echo body benchmark
oha -c 100 -z 30s -d '{"test": "data"}' -H "Content-Type: application/json" \
    http://localhost:3000/api/echo

# Compare against Node.js baseline
# Run same benchmarks against pure Node.js http server and Fastify
```

## 6. Implementation Plan

### Phase 1: Core Foundation (MVP)

**Goal**: Basic working server with Fetch Event API

| Task                                     | Priority | Complexity |
| ---------------------------------------- | -------- | ---------- |
| Setup napi-rs project with Cargo.toml    | P0       | Low        |
| Implement basic Axum server              | P0       | Medium     |
| Create ThreadsafeFunction handler bridge | P0       | High       |
| Implement RequestContext type            | P0       | Medium     |
| Implement JsResponse type                | P0       | Low        |
| Create FetchEvent TypeScript class       | P0       | Medium     |
| Create Request TypeScript class          | P0       | Medium     |
| Create Response TypeScript class         | P0       | Medium     |
| Basic hello world example                | P0       | Low        |

**Deliverables**:

- Working server that can handle simple requests
- Basic Request/Response classes
- Example "Hello World" server

### Phase 2: Production Features

**Goal**: Production-ready server with proper error handling

| Task                               | Priority | Complexity |
| ---------------------------------- | -------- | ---------- |
| Graceful shutdown                  | P1       | Medium     |
| Request timeout handling           | P1       | Medium     |
| Error propagation (Rust → JS)      | P1       | Medium     |
| Headers class (Map-like interface) | P1       | Low        |
| URL parsing (WHATWG URL)           | P1       | Low        |
| Body size limits                   | P1       | Low        |
| Connection limits                  | P1       | Medium     |
| Server statistics                  | P2       | Low        |

**Deliverables**:

- Proper error handling
- Configurable limits and timeouts
- Full Headers implementation

### Phase 3: Performance Optimization

**Goal**: Achieve target performance metrics

| Task                              | Priority | Complexity |
| --------------------------------- | -------- | ---------- |
| SO_REUSEPORT support              | P1       | Low        |
| Buffer pooling                    | P2       | Medium     |
| Request queue with backpressure   | P1       | Medium     |
| Body streaming for large payloads | P2       | High       |
| Zero-copy optimization audit      | P2       | Medium     |
| Benchmark suite                   | P1       | Medium     |
| Performance profiling             | P2       | Medium     |

**Deliverables**:

- Documented performance benchmarks
- Optimized memory usage
- Large body streaming support

### Phase 4: Advanced Features

**Goal**: Feature parity with production web servers

| Task                            | Priority | Complexity |
| ------------------------------- | -------- | ---------- |
| HTTP/2 support                  | P2       | Medium     |
| TLS support (rustls)            | P2       | Medium     |
| WebSocket support               | P3       | High       |
| Request body streaming API      | P2       | High       |
| FormData parsing                | P3       | Medium     |
| Middleware support              | P3       | Medium     |
| Cluster mode (worker processes) | P3       | High       |

**Deliverables**:

- HTTPS support
- WebSocket upgrade handling
- Full body parsing capabilities

## 7. Project Structure

```
fetch-rs/
├── Cargo.toml              # Rust dependencies
├── package.json            # Node.js package config
├── tsconfig.json           # TypeScript configuration
├── build.rs                # napi-rs build script
├── index.js                # Main entry point (generated)
├── index.d.ts              # TypeScript definitions (generated)
│
├── src/                    # Rust source files
│   ├── lib.rs              # Main napi-rs entry, Server export
│   ├── server.rs           # Axum HTTP server implementation
│   ├── request.rs          # RequestContext, body handling
│   ├── response.rs         # JsResponse, response conversion
│   ├── handler.rs          # ThreadsafeFunction bridge
│   ├── config.rs           # ServerOptions, configuration
│   └── error.rs            # Error types
│
├── lib/                    # TypeScript source files
│   ├── index.ts            # Main exports
│   ├── server.ts           # Server wrapper class
│   ├── fetch-event.ts      # FetchEvent class
│   ├── request.ts          # Request class
│   ├── response.ts         # Response class
│   └── headers.ts          # Headers class
│
├── examples/               # Usage examples
│   ├── hello-world.ts      # Basic hello world
│   ├── json-api.ts         # JSON API example
│   └── echo-body.ts        # Request body echo
│
├── tests/                  # Test files
│   ├── server.test.ts      # Integration tests
│   └── unit/               # Unit tests
│
├── benches/                # Benchmarks
│   ├── throughput.rs       # Rust benchmarks
│   └── comparison.ts       # JS comparison benchmarks
│
└── rfcs/                   # Design documents
    └── 00001.md            # This RFC
```

### Cargo.toml Dependencies

```toml
[package]
name = "fetch-rs"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
# napi-rs for Node.js bindings
napi = { version = "2", features = ["async", "tokio_rt"] }
napi-derive = "2"

# HTTP server stack
axum = "0.7"
hyper = { version = "1.0", features = ["server", "http1", "http2"] }
hyper-util = { version = "0.1", features = ["tokio"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["timeout", "limit"] }

# Async runtime
tokio = { version = "1", features = ["full"] }

# Utilities
bytes = "1"
http = "1.0"
http-body-util = "0.1"
socket2 = "0.5"
parking_lot = "0.12"
tracing = "0.1"

[build-dependencies]
napi-build = "2"

[profile.release]
lto = true
codegen-units = 1
opt-level = 3
```

### package.json

```json
{
  "name": "fetch-rs",
  "version": "0.1.0",
  "description": "High-performance web server with Fetch Event API",
  "main": "index.js",
  "types": "index.d.ts",
  "files": ["index.js", "index.d.ts", "lib/**/*.js", "lib/**/*.d.ts"],
  "scripts": {
    "build": "napi build --release",
    "build:debug": "napi build",
    "test": "vitest run",
    "bench": "tsx benches/comparison.ts"
  },
  "napi": {
    "name": "fetch-rs",
    "triples": {
      "defaults": true,
      "additional": [
        "x86_64-unknown-linux-musl",
        "aarch64-unknown-linux-gnu",
        "aarch64-apple-darwin",
        "aarch64-unknown-linux-musl"
      ]
    }
  },
  "devDependencies": {
    "@napi-rs/cli": "^2.18.0",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0",
    "tsx": "^4.0.0"
  }
}
```

## 8. Usage Examples

### Hello World Server

```typescript
import { Server } from "fetch-rs";

const server = new Server({ port: 3000 });

server.addEventListener("fetch", (event) => {
  event.respondWith(
    new Response("Hello, World!", {
      headers: { "Content-Type": "text/plain" },
    }),
  );
});

await server.listen();
console.log("Server listening on http://localhost:3000");
```

### JSON API

```typescript
import { Server, Response } from "fetch-rs";

const server = new Server({ port: 3000 });

server.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);

  if (url.pathname === "/api/users") {
    event.respondWith(
      Response.json({
        users: [
          { id: 1, name: "Alice" },
          { id: 2, name: "Bob" },
        ],
      }),
    );
    return;
  }

  if (url.pathname === "/api/health") {
    event.respondWith(Response.json({ status: "ok", timestamp: Date.now() }));
    return;
  }

  event.respondWith(Response.json({ error: "Not Found" }, { status: 404 }));
});

await server.listen();
```

### Request Body Handling

```typescript
import { Server, Response } from "fetch-rs";

const server = new Server({
  port: 3000,
  maxBodySize: 10 * 1024 * 1024, // 10MB limit
});

server.addEventListener("fetch", async (event) => {
  const { request } = event;
  const url = new URL(request.url);

  if (url.pathname === "/api/echo" && request.method === "POST") {
    // Echo the request body
    const body = await request.text();
    event.respondWith(
      new Response(body, {
        headers: { "Content-Type": request.headers.get("Content-Type") || "text/plain" },
      }),
    );
    return;
  }

  if (url.pathname === "/api/json" && request.method === "POST") {
    // Parse and transform JSON
    const data = await request.json();
    event.respondWith(
      Response.json({
        received: data,
        processedAt: new Date().toISOString(),
      }),
    );
    return;
  }

  event.respondWith(new Response("Not Found", { status: 404 }));
});

await server.listen();
```

### Using waitUntil for Background Tasks

```typescript
import { Server, Response } from "fetch-rs";

const server = new Server({ port: 3000 });

server.addEventListener("fetch", (event) => {
  // Respond immediately
  event.respondWith(Response.json({ status: "accepted" }, { status: 202 }));

  // Continue processing in background
  event.waitUntil(
    (async () => {
      // Log analytics, send notifications, etc.
      await fetch("https://analytics.example.com/event", {
        method: "POST",
        body: JSON.stringify({ path: event.request.url }),
      });
    })(),
  );
});

await server.listen();
```

## 9. Risks and Mitigations

| Risk                                 | Impact        | Mitigation                                             |
| ------------------------------------ | ------------- | ------------------------------------------------------ |
| ThreadsafeFunction overhead          | Performance   | Use single shared instance, benchmark call patterns    |
| Memory leaks in long-running servers | Stability     | Implement proper cleanup, test with valgrind/heaptrack |
| Complexity of zero-copy patterns     | Maintenance   | Thorough documentation, integration tests              |
| Breaking changes in napi-rs          | Compatibility | Pin versions, test upgrades                            |
| JavaScript handler exceptions        | Stability     | Proper error boundaries, timeout handling              |

## 10. Alternatives Considered

### Alternative HTTP Frameworks

| Framework      | Pros                       | Cons                                   | Decision      |
| -------------- | -------------------------- | -------------------------------------- | ------------- |
| Actix-web      | Fastest benchmarks         | Actor model complexity, less ecosystem | Rejected      |
| Hyper (direct) | Maximum control            | More boilerplate                       | Too low-level |
| Warp           | Filter-based routing       | Less flexible                          | Rejected      |
| **Axum**       | Tower ecosystem, ergonomic | Slightly slower than Actix             | **Selected**  |

### Alternative Node.js Binding Approaches

| Approach     | Pros                         | Cons                        | Decision     |
| ------------ | ---------------------------- | --------------------------- | ------------ |
| Node-API (C) | Direct control               | Manual memory management    | Too complex  |
| node-bindgen | Simpler API                  | Less mature, fewer features | Rejected     |
| **napi-rs**  | Type-safe, zero-copy support | Rust compilation time       | **Selected** |

## 11. References

- [napi-rs Documentation](https://napi.rs/)
- [Axum Documentation](https://docs.rs/axum/latest/axum/)
- [WinterCG Fetch Standard](https://fetch.spec.whatwg.org/)
- [Cloudflare Workers FetchEvent](https://developers.cloudflare.com/workers/runtime-apis/fetch-event/)
- [tokio-rs Runtime](https://tokio.rs/)
- [hyper HTTP Library](https://hyper.rs/)
